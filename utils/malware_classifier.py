import os
import re
from typing import Dict, Optional, Any, List
from config import MALWARE_CLASSIFICATIONS


class MalwareClassifier:
    def __init__(self):
        # 파일명 기반 분류 패턴
        self.filename_patterns = {
            'emotet': [r'emotet', r'invoice.*\.doc', r'payment.*\.xls', r'receipt.*\.pdf'],
            'trickbot': [r'trickbot', r'bank.*statement', r'financial.*report'],
            'qakbot': [r'qakbot', r'qbot', r'document.*\d+\.doc'],
            'formbook': [r'formbook', r'form.*\.exe', r'application.*\.scr'],
            'agent_tesla': [r'agent.*tesla', r'keylogger', r'stealer'],
            'lokibot': [r'loki', r'password.*stealer', r'credential'],
        }

        # 특징 기반 분류 규칙
        self.feature_rules = {
            'macro_malware': {
                'has_macro': True,
                'macro_suspicious_count': (5, float('inf')),
                'file_extensions': ['.docm', '.xlsm', '.pptm']
            },
            'pdf_exploit': {
                'pdf_js_count': (1, float('inf')),
                'pdf_openaction': True,
                'file_extensions': ['.pdf']
            },
            'hwp_malware': {
                'hwp_scripts': (1, float('inf')),
                'file_extensions': ['.hwp', '.hwpx', '.hwpml']
            }
        }

        # 내용 기반 시그니처
        self.content_signatures = {
            'emotet': [b'Enable Editing', b'Enable Content', b'urlmon.dll', b'WinHttpRequest'],
            'trickbot': [b'banking', b'credential', b'browser', b'cookie'],
            'formbook': [b'keylog', b'screenshot', b'clipboard'],
            'pdf_exploit': [b'JavaScript', b'/JS', b'eval(', b'unescape(']
        }

    def classify_malware(self, file_path: str, features: Dict[str, Any]) -> Optional[Dict[str, str]]:
        """악성코드 분류 및 상세 정보 반환"""

        file_name = os.path.basename(file_path).lower()
        file_ext = os.path.splitext(file_path)[1].lower()

        # 1. 파일명 기반 분류
        filename_type = self._classify_by_filename(file_name)
        if filename_type:
            return self._get_classification_info(filename_type)

        # 2. 특징 기반 분류
        feature_type = self._classify_by_features(features, file_ext)
        if feature_type:
            return self._get_classification_info(feature_type)

        # 3. 내용 기반 분류
        content_type = self._classify_by_content(file_path)
        if content_type:
            return self._get_classification_info(content_type)

        # 4. 기본 분류 (파일 타입 기반)
        default_type = self._get_default_classification(file_ext, features)
        return self._get_classification_info(default_type)

    def _classify_by_filename(self, filename: str) -> Optional[str]:
        """파일명 패턴으로 분류"""
        for malware_type, patterns in self.filename_patterns.items():
            for pattern in patterns:
                if re.search(pattern, filename, re.IGNORECASE):
                    return malware_type
        return None

    def _classify_by_features(self, features: Dict[str, Any], file_ext: str) -> Optional[str]:
        """추출된 특징으로 분류"""
        for malware_type, criteria in self.feature_rules.items():

            # 파일 확장자 체크
            if 'file_extensions' in criteria:
                if file_ext not in criteria['file_extensions']:
                    continue

            # 특징 조건 체크
            matches = True
            for feature_name, condition in criteria.items():
                if feature_name == 'file_extensions':
                    continue

                feature_value = features.get(feature_name)

                if isinstance(condition, bool):
                    if feature_value != condition:
                        matches = False
                        break
                elif isinstance(condition, tuple) and len(condition) == 2:
                    min_val, max_val = condition
                    if not (min_val <= (feature_value or 0) <= max_val):
                        matches = False
                        break

            if matches:
                return malware_type

        return None

    def _classify_by_content(self, file_path: str) -> Optional[str]:
        """파일 내용의 시그니처로 분류"""
        try:
            with open(file_path, 'rb') as f:
                content = f.read()

            for malware_type, signatures in self.content_signatures.items():
                signature_matches = 0
                for signature in signatures:
                    if signature in content:
                        signature_matches += 1

                # 시그니처 2개 이상 매치되면 해당 타입으로 분류
                if signature_matches >= 2:
                    return malware_type

        except Exception:
            pass

        return None

    def _get_default_classification(self, file_ext: str, features: Dict[str, Any]) -> str:
        """기본 분류 (파일 타입 기반)"""

        # 매크로가 있는 Office 문서
        if features.get('has_macro') and file_ext in ['.docm', '.xlsm', '.pptm']:
            return 'macro_malware'

        # JavaScript가 있는 PDF
        if features.get('pdf_js_count', 0) > 0 and file_ext == '.pdf':
            return 'pdf_exploit'

        # 스크립트가 있는 HWP
        if features.get('hwp_scripts', 0) > 0 and file_ext in ['.hwp', '.hwpx', '.hwpml']:
            return 'hwp_malware'

        # 일반적인 Office 문서 악성코드
        if file_ext in ['.docx', '.xlsx', '.pptx', '.doc', '.xls', '.ppt']:
            return 'generic_office'

        return 'generic_office'

    def _get_classification_info(self, malware_type: str) -> Dict[str, str]:
        """분류 정보를 상세 정보와 함께 반환"""
        classification = MALWARE_CLASSIFICATIONS.get(malware_type, {
            'family': f'Unknown.{malware_type.title()}',
            'type': '미분류 악성코드',
            'threat_level': '중간',
            'description': '정확한 분류가 어려운 악성코드입니다.'
        })

        return {
            'classification_type': malware_type,
            'family': classification['family'],
            'type': classification['type'],
            'threat_level': classification['threat_level'],
            'description': classification['description']
        }

    def get_threat_assessment(self, classification_info: Dict[str, str], features: Dict[str, Any]) -> Dict[str, Any]:
        """위협 평가 및 상세 분석"""

        threat_level = classification_info['threat_level']

        # 위험도 점수 계산 (1-10)
        risk_score = self._calculate_risk_score(classification_info, features)

        # 예상 피해 유형
        damage_types = self._get_potential_damages(classification_info['classification_type'])

        # 권장 대응 방안
        recommendations = self._get_recommendations(classification_info['classification_type'], risk_score)

        return {
            'risk_score': risk_score,
            'threat_level': threat_level,
            'potential_damages': damage_types,
            'recommendations': recommendations,
            'urgency': 'High' if risk_score >= 8 else 'Medium' if risk_score >= 5 else 'Low'
        }

    def _calculate_risk_score(self, classification_info: Dict[str, str], features: Dict[str, Any]) -> int:
        """위험도 점수 계산 (1-10)"""

        base_scores = {
            'emotet': 9, 'trickbot': 9, 'qakbot': 8,
            'formbook': 7, 'agent_tesla': 7, 'lokibot': 6,
            'pdf_exploit': 8, 'macro_malware': 6, 'hwp_malware': 5,
            'generic_office': 4
        }

        classification_type = classification_info['classification_type']
        score = base_scores.get(classification_type, 5)

        # 특징 기반 점수 조정
        if features.get('has_macro'):
            score += 1
        if features.get('pdf_js_count', 0) > 5:
            score += 2
        if features.get('suspicious_keywords_count', 0) > 10:
            score += 1
        if features.get('entropy', 0) > 7.5:
            score += 1

        return min(10, max(1, score))

    def _get_potential_damages(self, classification_type: str) -> List[str]:
        """예상 피해 유형 반환"""

        damage_map = {
            'emotet': ['금융정보 탈취', '이메일 계정 탈취', '추가 악성코드 다운로드', '네트워크 내 확산'],
            'trickbot': ['온라인 뱅킹 자격증명 탈취', '암호화폐 지갑 정보 탈취', '원격 제어 권한 획득'],
            'qakbot': ['이메일 자격증명 탈취', '금융정보 수집', '네트워크 정찰', '횡적 이동'],
            'formbook': ['키보드 입력 기록', '웹브라우저 정보 탈취', '저장된 패스워드 수집'],
            'agent_tesla': ['원격 모니터링', '키로깅', '스크린샷 캡처', '웹캠 액세스'],
            'lokibot': ['FTP 자격증명 탈취', '웹브라우저 패스워드 수집', '이메일 계정 정보 탈취'],
            'pdf_exploit': ['PDF 뷰어 취약점 악용', '시스템 권한 획득', '악성코드 다운로드 및 실행'],
            'macro_malware': ['매크로를 통한 악성코드 실행', '시스템 설정 변경', '추가 페이로드 다운로드'],
            'hwp_malware': ['HWP 뷰어 취약점 악용', '문서 내 스크립트 실행', '시스템 정보 수집']
        }

        return damage_map.get(classification_type, ['시스템 침해', '데이터 손실'])

    def _get_recommendations(self, classification_type: str, risk_score: int) -> List[str]:
        """권장 대응 방안 반환"""

        base_recommendations = [
            '즉시 파일 격리 및 삭제',
            '안티바이러스 전체 검사 실행',
            '시스템 및 소프트웨어 최신 업데이트',
            '의심스러운 네트워크 활동 모니터링'
        ]

        specific_recommendations = {
            'emotet': ['이메일 계정 패스워드 즉시 변경', '온라인 뱅킹 계정 보안 점검'],
            'trickbot': ['모든 금융 계정 패스워드 변경', '암호화폐 지갑 보안 점검'],
            'pdf_exploit': ['PDF 뷰어 최신 버전으로 업데이트', 'JavaScript 실행 비활성화 고려'],
            'macro_malware': ['Office 매크로 보안 설정 강화', '매크로 자동 실행 비활성화']
        }

        recommendations = base_recommendations.copy()
        recommendations.extend(specific_recommendations.get(classification_type, []))

        if risk_score >= 8:
            recommendations.extend(['전문가 상담 권장', '시스템 완전 초기화 고려'])

        return recommendations


def classify_malware(file_path: str, features: Dict[str, Any]) -> Optional[Dict[str, str]]:
    """악성코드 분류 함수 (메인에서 호출)"""
    classifier = MalwareClassifier()
    classification = classifier.classify_malware(file_path, features)

    if classification:
        # 위협 평가도 함께 수행
        threat_assessment = classifier.get_threat_assessment(classification, features)
        classification.update(threat_assessment)

    return classification


if __name__ == "__main__":
    # 간단 테스트
    classifier = MalwareClassifier()

    test_features = {
        'has_macro': True,
        'macro_suspicious_count': 8,
        'pdf_js_count': 0,
        'suspicious_keywords_count': 5,
        'entropy': 7.2
    }

    test_file = "test_invoice.docm"

    result = classifier.classify_malware(test_file, test_features)
    if result:
        print("=== 악성코드 분류 결과 ===")
        print(f"분류: {result['family']}")
        print(f"유형: {result['type']}")
        print(f"위험도: {result['threat_level']}")
        print(f"위험 점수: {result.get('risk_score', 0)}/10")
        print(f"권장 대응: {result.get('recommendations', ['없음'])[0]}")
    else:
        print("분류 실패")